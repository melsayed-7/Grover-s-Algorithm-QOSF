%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% CSCI 1430 Writeup Template
%
% This is a LaTeX document. LaTeX is a markup language for producing
% documents. Your task is to fill out this
% document, then to compile this into a PDF document.
% You will then upload this PDF to `Gradescope' - the grading system

\documentclass[11pt]{article}


\usepackage{braket}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage[colorlinks = true,
linkcolor = blue,
urlcolor  = blue]{hyperref}
\usepackage[a4paper,margin=1.5in]{geometry}
\usepackage{stackengine,graphicx}
\usepackage{fancyhdr}
\setlength{\headheight}{15pt}
\usepackage{microtype}
\usepackage{times}
\usepackage{booktabs}


\frenchspacing
\setlength{\parindent}{0cm} % Default is 15pt.
\setlength{\parskip}{0.3cm plus1mm minus1mm}

\pagestyle{fancy}
\fancyhf{}
\lhead{Image filtering project}
\rhead{CIE 552}
\rfoot{\thepage}

\date{}

\title{\vspace{-1cm}Finding the lowest eigenvalue of a Hamiltonian Using Variation Quantum Eigensolver (VQE)}

\usepackage{listings}
\usepackage{color}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}

\lstdefinestyle{mystyle}{
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\footnotesize,
	breakatwhitespace=false,
	breaklines=true,
	captionpos=b,
	keepspaces=true,
	numbers=left,
	numbersep=5pt,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=2
}

\lstset{style=mystyle, language=python , frame=single}

\begin{document}
	
	\maketitle	
	
	\vspace{-3cm}
	\thispagestyle{fancy}
	
	
	\section*{Definitions}
	
	
	{\addtolength{\leftskip}{7mm}
		
		
	Let's start by defining some definitions that we will use later in this document:
	
	- \textbf{Hamiltonian}: 
	A Hamiltonian is an operator that describes the sum of kinetic and potential energies in a given system. Here is an expression of a the Hamiltonian: 
	
	$\displaystyle {\hat{H}}={\hat{T}}+{\hat{V}}$
	
	where $\hat{T}$ represent the operator of the kinetic energy and $\hat{V}$ represent the operator of the potential energy.
	
	
	- \textbf{Eigenstate}
	An Eigenstate represent a possible energy state of the system. For example, if we have a Hydrogen atom, a possible state is to have the electron in the first orbital, and because this is the lowest energy state this atom can have, we call this state the "ground state". we can represent anystate using the bra-ket notation $\ket{\psi}$ which can be any possible energy state of the system. what make Eignestates different from other states is that it we can represent any state using combination of the Eignenstates.
	
	
	- \textbf{Eigenvalue}
	Each Eigenvalue represents the quantity or the weight of contribution the corresponding Eigenstate to the current state of the system. $\lambda$ represents the Eigenvalue.

   	}
	
	
	\section*{Problem Statement}
	{\addtolength{\leftskip}{7mm}
		In this task we are given a Hamiltonian of a system and we are asked to find the ground state of that system
	}
	


	\section*{Filter tests and results}
	
	{\Large \textbf{Identity filter}}
	
	\begin{figure}[h]
		\centering
		%    \includegraphics[width=5cm]{placeholder.jpg}
		%    \includegraphics[width=5cm]{placeholder.jpg}
		\caption{\emph{Left:} My result was spectacular. \emph{Right:} Curious.}
		\label{fig:result1}
	\end{figure}
	
	
	
	
	\newpage
	\section*{Generation of Hybrid Image}
	In this part we are trying to add a low-pass filtered image and then add it to a high-pass filtered image of the same shape. This was implemented using 2 ways of filtering the first used the spatial convolution of the filter and the latter was done in frequency domain. The good thing of the frequency domain thing is that the convolution becomes a normal multiplication. 
	
	The kernel used is a Gaussian kernel with size 15x15 and $\sigma = 10$.
	This is how the low-pass filtered image was obtained and the high-filtered images was obtained by subtracting the low frequencies from the original image and this kept only high frequencies. 
	
	
	
	Here is a code snippet of the function implemented 2 times one with spatial convolution and the second using FFT-based convolution
	
	
	\begin{lstlisting}
	
	def gen_hybrid_image(image1, image2, cutoff_frequency):
	
	assert image1.shape == image2.shape
	
	ksize = 15
	sigma = cutoff_frequency
	
	
	# Here I do outer product of 2 gaussian vectors to get 2D kernel
	x = np.arange(-ksize//2, ksize//2+1)
	gx = np.exp(-(x)**2/(2*sigma**2))
	g = np.outer(gx, gx)
	g /= np.sum(g)
	kernel = g
	
	
	
	# Your code here:
	# looping over the channels of the image to apply the gaussian kernel
	low_frequencies = np.zeros(image1.shape, dtype=np.float32)
	
	for i in range(image1.shape[2]):
	low_frequencies[:,:,i] = correlate2d(image1[:,:,i], kernel, 'same') # Replace with your implementation
	
	# (2) Remove the low frequencies from image2. The easiest way to do this is to
	#     subtract a blurred version of image2 from the original version of image2.
	#     This will give you an image centered at zero with negative values.
	
	low_frequencies2 = np.zeros(image2.shape, dtype=np.float32)
	
	for i in range(image1.shape[2]):
	low_frequencies2[:,:,i] = correlate2d(image2[:,:,i], kernel,'same')
	
	
	
	
	
	high_frequencies = image2 - low_frequencies2 # Replace with your implementation
	
	
	# print(np.sum(high_frequencies<0))
	
	# (3) Combine the high frequencies and low frequencies
	
	hybrid_image = low_frequencies/2 + high_frequencies/2 # Replace with your implementation
	
	high_frequencies = np.clip(high_frequencies,-1.0,1.0)
	hybrid_image = np.clip(hybrid_image,0,1)
	
	# np.clip(low_frequencies,0,1)
	# np.clip(high_frequencies,0,1)
	# np.clip(hybrid_image,0,1)
	return low_frequencies, high_frequencies, hybrid_image
	
	
	\end{lstlisting}
	
	\newpage
	
	\begin{lstlisting}
	def gen_hybrid_image_fft(image1, image2, cutoff_frequency):
	assert image1.shape == image2.shape
	
	ksize = 15
	sigma = cutoff_frequency
	
	x = np.arange(-ksize//2, ksize//2+1)
	gx = np.exp(-(x)**2/(2*sigma**2))
	g = np.outer(gx, gx)
	g /= np.sum(g)
	kernel = g
	
	
	# Applyingthe fft convolution on each channel
	low_freqs = np.zeros(image1.shape)
	for i in range(image1.shape[2]):
	low_freqs[:,:,i] = fft_convolve(image1[:,:,i], kernel)
	
	
	
	low_freqs2 = np.zeros(image2.shape)
	for i in range(image1.shape[2]):
	low_freqs2[:,:,i] = fft_convolve(image2[:,:,i], kernel)
	
	
	# getting only high freqs of image2
	high_freqs = image2 - low_freqs2
	
	
	# combining the low freqs and high freqs
	hybrid_image = low_freqs/2 + high_freqs/2 # Replace with your implementation
	
	high_freqs = np.clip(high_freqs,-1.0,0.5)
	hybrid_image = np.clip(hybrid_image,0,1)
	
	return low_freqs, high_freqs, hybrid_image
	
	
	\end{lstlisting}
	\newpage
	
	\section{Results}
	The code worked perfectly in both spatial and FFT-based convolution.
	
	
	Here are the 2 images I used:
	
	low Frequencies

	
	
	
	
\end{document}
